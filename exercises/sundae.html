<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Testing Drag And Drop</title>
<style>
.pointer {
    cursor: pointer;
}
</style>
</head>
<body>
<div class="wrap">
   <canvas id="canvas" width="500" height="400">
      This text is displayed if your browser does not support HTML5 Canvas.
   </canvas>
</div>

<script type="text/javascript">

let hsl = (h, s, l) => `hsl(${h},${s}%,${l}%)`

let canvas = document.getElementById('canvas')
let ctx = canvas.getContext('2d')

let w = canvas.width = window.innerWidth * 0.9;
let h = canvas.height = window.innerHeight * 0.9;

//Background stuff, we don't need it!
/*
let drawBG = context => {

    context.save()

    context.fillStyle = 'white'
    context.fillRect(0, 0, w, h)
    context.lineWidth = 0.3;
    context.strokeStyle = 'lightgray'
    context.fillStyle = 'black'

    for (let i = 1; i < w; i++) {
        context.beginPath()
        if (i % 10 === 0) {
            context.moveTo(i, 0);
            context.lineTo(i, h)
            context.moveTo(i, 0);
        }
        context.closePath()
        context.stroke()
    }

    for (let i = 1; i < h; i++) {
        context.beginPath()
        if (i % 10 === 0) {
            context.moveTo(0, i)
            context.lineTo(w, i)
            context.moveTo(0, i)
        }
        context.closePath()
        context.stroke()
    }


    context.lineWidth = 1
    context.strokeStyle = 'gray'

    context.beginPath()
    for (let i = 50; i < w; i += 10) {
        if (i % 50 === 0) {
            context.moveTo(i, 0)
            context.lineTo(i, 30)
            context.fillText(` ${i}`, i, 30)
        } else {
            context.moveTo(i, 0)
            context.lineTo(i, 10)
        }

    }
    context.closePath()
    context.stroke()

    context.beginPath()
    for (let i = 50; i < h; i += 10) {
        if (i % 50 === 0) {
            context.moveTo(0, i)
            context.lineTo(30, i)
            context.fillText(` ${i}`, 30, i)
        } else {
            context.moveTo(0, i)
            context.lineTo(10, i)
        }

    }
    context.closePath()
    context.stroke()

    context.restore()
}

drawBG(ctx2)
*/

class Square {
    constructor(x, y, edge, image, outline) {

        this.image = image
        this.x = x
        this.y = y
        this.edge = edge
        this.selected = false
        this.active = false
        this.outline = outline

    }
    draw(context) {
        //context.fillStyle = "gray"

        //context.fillRect(this.x, this.y, this.edge, this.edge)
        context.drawImage(this.image, this.x, this.y, this.edge, this.edge)
        if (this.outline) {
            context.lineWidth = 2;
            context.strokeStyle = "gray"
            context.strokeRect(this.x, this.y, this.edge, this.edge)
        }
    }
    update() {
        this.x += 0.1
    }

    select() {
        this.selected = !this.selected
    }

    activate() {
        this.active = !this.active
    }
}


let aImg = new Image();
aImg.src = 'img/A.png';

let bImg = new Image();
bImg.src = 'img/B.png';

let cImg = new Image();
cImg.src = 'img/C.png';

let gImg = new Image();
gImg.src = 'img/garbage.png'

let sundaeImg = new Image()
sundaeImg.src = 'img/sundaeCup.png'
let iceCreamImg = new Image()
iceCreamImg.src = 'img/iceCream.png'
let cherryImg = new Image()
cherryImg.src = 'img/cherry.png'
let strawberryImg = new Image()
strawberryImg.src = 'img/strawberry.png'

let sources = new Array()
sources.push(new Square(40, 40, 60, iceCreamImg, true))
sources.push(new Square(40, 140, 60, cherryImg, true))
sources.push(new Square(40, 240, 60, strawberryImg, true))

let background = new Array()

let foreground = new Array()
foreground.push(new Square(200, 100, 400, sundaeImg))

let garbage = new Square(40, 500, 60, gImg, true)

let draggables = new Array()

//let draggables = new Array(10).fill().map(() => new Square(Math.random() * w, Math.random() * h, 60, hsl(Math.floor(Math.random() * 360), 100, 50), aImg))


let getMouseCoords = (canvas, event) => {
    let canvasCoords = canvas.getBoundingClientRect()
    return {
        x: event.pageX - canvasCoords.left,
        y: event.pageY - canvasCoords.top
    }
}

let getOffsetCoords = (mouse, rect) => {
    return {
        x: mouse.x - rect.x,
        y: mouse.y - rect.y
    }
}


let cursorInRect = (mouseX, mouseY, rectX, rectY, rectW, rectH) => {
    let xLine = mouseX > rectX && mouseX < rectX + rectW
    let yLine = mouseY > rectY && mouseY < rectY + rectH

    return xLine && yLine
}


///DRAW BUTTON NONSENSE
// Draw "button" on canvas
  const button = {
    x: 600,
    y: 500,
    width: 100,
    height: 30,
    text: 'Save Image'
  };

  function drawButton() {
    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(button.x, button.y, button.width, button.height);
    ctx.fillStyle = 'white';
    ctx.font = '16px Arial';
    ctx.fillText(button.text, button.x + 10, button.y + 20);
  }

  // Handle canvas clicks
  canvas.addEventListener('click', function (e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (
      x >= button.x &&
      x <= button.x + button.width &&
      y >= button.y &&
      y <= button.y + button.height
    ) {
      const image = canvas.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = image;
      link.download = 'canvas-image.png';
      link.click();
      document.body.removeChild(link); // Remove after click
    }
  });


// =============================================================
//                          HANDLERS
// =============================================================


window.addEventListener('resize', () => {
    w = canvas.width = window.innerWidth * 0.9;
    h = canvas.height = window.innerHeight * 0.9;
    //drawBG(ctx2)
})

canvas.addEventListener('click', e => {
    let mouse = getMouseCoords(canvas, e)
})

canvas.addEventListener('mousemove', e => {
    let mouse = getMouseCoords(canvas, e)

    let arr = draggables.map(e => cursorInRect(mouse.x, mouse.y, e.x, e.y, e.edge, e.edge))
    !arr.every(e => e === false) ? canvas.classList.add('pointer') : canvas.classList.remove('pointer')

    draggables.forEach(e => {

        if (e.selected) {
            e.x = mouse.x - e.offset.x
            e.y = mouse.y - e.offset.y
        }

        cursorInRect(mouse.x, mouse.y, e.x, e.y, e.edge, e.edge) ?
            e.active != true ? e.activate() : false
            : e.active = false
    })



})


canvas.addEventListener('mousedown', e => {
    let found = false
    let mouse = getMouseCoords(canvas, e)

    for (let i = draggables.length - 1; i >=0; i--) {
        if (found) { return }
        let e = draggables[i]
        if (cursorInRect(mouse.x, mouse.y, e.x, e.y, e.edge, e.edge)) {
            e.selected = true
            e.offset = getOffsetCoords(mouse, e)

            // Remove the element and push it to the end
            const [element] = draggables.splice(i, 1);
            draggables.push(element);

            found = true
        } else {
            e.selected = false
        }    
    }
    if (found) { return }


    sources.forEach(e => {
        if (cursorInRect(mouse.x, mouse.y, e.x, e.y, e.edge, e.edge)) {
            let newDraggable = new Square(e.x - e.edge / 2, e.y - e.edge / 2, e.edge * 2, e.image)
            newDraggable.selected = true
            newDraggable.offset = getOffsetCoords(mouse, newDraggable)
            draggables.push(newDraggable)
            found = true
        }
    })
})

canvas.addEventListener('mouseup', eV => {
    draggables.forEach(e => {
        if (e.selected) {
            e.selected = false
            let mouse = getMouseCoords(canvas, eV)

            if (cursorInRect(mouse.x, mouse.y, garbage.x, garbage.y, garbage.edge, garbage.edge)) {
                draggables.pop() //Should always be the selected one
            }
        }
    })
})



// =============================================================
//                          MAIN LOOP
// =============================================================

function animate() {
    ctx.clearRect(0, 0, w, ctx.canvas.height)
    ctx.fillStyle = 'white'

    drawButton();
    background.forEach(e => {
        e.draw(ctx)
    })
    sources.forEach(e => {
        e.draw(ctx)
    })
    garbage.draw(ctx)
    draggables.forEach(e => {
        e.draw(ctx)
    })
    foreground.forEach(e => {
        e.draw(ctx)
    })
    window.requestAnimationFrame(animate)
}

animate()



</script>

</body>
</html>

