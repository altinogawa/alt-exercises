<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shapes!!</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      touch-action: none; /* Prevent default gestures */
	  display: block; /* removes inline spacing */
    }
	body, html {
      margin: 0;
      padding: 0;
    }
  </style>
  <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico?">
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
  
let colorNames = ['red', 'yellow', 'blue', 'green', 'purple', 'orange', 'pink', 'brown', 'white', 'black'];
let shapeNames = ['circle', 'triangle', 'square', 'rectangle', 'heart', 'diamond', 'star'];


  function getPath(shape) {
    const path = new Path2D();
    switch (shape) {
      case 'circle':
        path.arc(0, 0, 50, 0, Math.PI * 2);
        break;
      case 'square':
        path.rect(-50, -50, 100, 100);
        break;
      case 'rectangle':
        path.rect(-60, -40, 120, 80);
        break;
      case 'triangle':
        path.moveTo(0, -60);
        path.lineTo(50, 40);
        path.lineTo(-50, 40);
        path.closePath();
        break;
      case 'diamond':
        path.moveTo(0, -60);
        path.lineTo(40, 0);
        path.lineTo(0, 60);
        path.lineTo(-40, 0);
        path.closePath();
        break;
      case 'star':
        for (let i = 0; i < 5; i++) {
          const angle = i * (Math.PI * 2) / 5;
          const outerX = Math.cos(angle) * 50;
          const outerY = Math.sin(angle) * 50;
          path.lineTo(outerX, outerY);
          const innerAngle = angle + Math.PI / 5;
          const innerX = Math.cos(innerAngle) * 25;
          const innerY = Math.sin(innerAngle) * 25;
          path.lineTo(innerX, innerY);
        }
        path.closePath();
        break;
      case 'heart':
        path.moveTo(0, 0);
        path.bezierCurveTo(0, -30, -50, -30, -50, 0);
        path.bezierCurveTo(-50, 30, 0, 50, 0, 60);
        path.bezierCurveTo(0, 50, 50, 30, 50, 0);
        path.bezierCurveTo(50, -30, 0, -30, 0, 0);
        break;
    }
    return path;
  }


//Square Class
class Square {
    constructor(x, y, edge, image, outline) {
        this.image = image
        this.x = x
        this.y = y
        this.edge = edge
        this.selected = false
        this.active = false
        this.outline = outline

    }
    draw(context) {
        context.drawImage(this.image, this.x, this.y, this.edge, this.edge)
        if (this.outline) {
			if(this.selected) {
			  context.linewidth = 5
              context.strokeStyle = "red"
            } else  {
              context.lineWidth = 2;
              context.strokeStyle = "gray"
			}
            context.strokeRect(this.x, this.y, this.edge, this.edge)
        }
    }
    select() {
        this.selected = !this.selected
    }

    activate() {
        this.active = !this.active
    }
}

//ShapeSquare Class
class ShapeSquare {
    constructor(x, y, edge, shape, outline) {
        this.shape = shape
        this.x = x
        this.y = y
        this.edge = edge
        this.selected = false
        this.active = false
        this.outline = outline

    }
    draw(context) {
	
        context.save();
        context.translate(this.x + this.edge / 2, this.y + this.edge / 2);
        //context.rotate(this.rotation);
        context.scale(0.4, 0.4);
        context.fillStyle = currentColor

        const path = getPath(this.shape);
    
        context.fill(path);
        context.restore();
	
        if (this.outline) {
            context.lineWidth = 2;
            context.strokeStyle = "gray"
            context.strokeRect(this.x, this.y, this.edge, this.edge)
        }
    }
    select() {
        this.selected = !this.selected
    }

    activate() {
        this.active = !this.active
    }
}

//ColorSquare Class
class ColorSquare {
    constructor(x, y, edge, color, outline) {
        this.color = color
        this.x = x
        this.y = y
        this.edge = edge
        this.selected = false
        this.active = false
        this.outline = outline

    }
    draw(context) {
	
        context.fillStyle = this.color
        context.fillRect(this.x + 2, this.y + 2, this.edge - 4, this.edge - 4)
		
        if (this.outline) {
            context.lineWidth = 2;
            context.strokeStyle = "gray"
            context.strokeRect(this.x, this.y, this.edge, this.edge)
        }
    }
    select() {
        this.selected = !this.selected
    }

    activate() {
        this.active = !this.active
    }
}

//Shape Class
class CanvasShape {
  constructor(x, y, scaleX = 1, scaleY = 1, color = 'red', shape = 'circle') {
    this.x = x;
    this.y = y;
    this.scaleX = scaleX;
    this.scaleY = scaleY;
    this.rotation = 0;
    this.color = color;
    this.shape = shape;

    this.touchStartInfo = null;
  }


  render(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.scale(this.scaleX, this.scaleY);
    ctx.fillStyle = this.color;

    const path = getPath(this.shape);
    

    ctx.fill(path);
    ctx.restore();
  }

  containsPoint(x, y, ctx) {
    ctx.save();
    ctx.scale(1 / this.scaleX, 1 / this.scaleY);
    ctx.rotate(-1 * this.rotation);
    ctx.translate(-1 * this.x, -1 * this.y);


    

    const path = getPath(this.shape)

    //Transform the mouse xy to properly match it
    const matrix = ctx.getTransform(); // DOMMatrix
    const newPoint = this.transformPoint(x, y, matrix)

    ctx.restore();

    return ctx.isPointInPath(path, newPoint.x, newPoint.y);
  }

  transformPoint(x, y, m) {
    return {
        x: m.a * x + m.c * y + m.e,
        y: m.b * x + m.d * y + m.f
    };
  }

  handleTouchStart(e) {
    if (e.touches.length === 1) {
      this.touchStartInfo = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
    } else if (e.touches.length === 2) {
      const [t1, t2] = e.touches;
      this.touchStartInfo = {
        distance: Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY),
        angle: Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX),
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        rotation: this.rotation
      };
    }
  }

  handleTouchMove(e) {
    if (e.touches.length === 1 && this.touchStartInfo) {
      const dx = e.touches[0].clientX - this.touchStartInfo.x;
      const dy = e.touches[0].clientY - this.touchStartInfo.y;
      this.x += dx;
      this.y += dy;
      this.touchStartInfo.x = e.touches[0].clientX;
      this.touchStartInfo.y = e.touches[0].clientY;
    } else if (e.touches.length === 2 && this.touchStartInfo) {
      const [t1, t2] = e.touches;
      const newDistance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      const newAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);

      const scaleFactor = newDistance / this.touchStartInfo.distance;
      this.scaleX = this.touchStartInfo.scaleX * scaleFactor;
      this.scaleY = this.touchStartInfo.scaleY * scaleFactor;
      this.rotation = this.touchStartInfo.rotation + (newAngle - this.touchStartInfo.angle);
    }
  }

  handleTouchEnd(e) {
    this.touchStartInfo = null;
  }
}

class LinePath {
    constructor(points, thickness, color) {
		this.path = null
        this.points = points
        this.thickness = thickness
        this.color = color

    }
}

//Canvas 
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

//Array for the shapes, with initial conditions
const shapes = new Array()
//shapes.push(new CanvasShape(300, 200, 1, 1, 'pink', 'diamond'))
//shapes.push(new CanvasShape(100, 100, 1, 1, 'green', 'circle'))

//Create the new color menu on the left!
const colorButtons = new Array()
for (let i = 0; i < colorNames.length; i++) {
  colorButtons.push(new ColorSquare(20, 100 + 80 * i, 60, colorNames[i], true))
}

//Now we do the shape buttons!!
const shapeButtons = new Array()
for (let i = 0; i < shapeNames.length; i++) {
  shapeButtons.push(new ShapeSquare(100, 100 + 80 * i, 60, shapeNames[i], true))
}

//Garbage image icon
let gImg = new Image();
gImg.src = 'garbage.png' //FIX THIS
let garbage = new Square(500, 20, 60, gImg, true)

//Reset image icon
let rImg = new Image();
rImg.src = 'A.png' //FIX THIS
let resetButton = new Square(420, 20, 60, rImg, true)

//Pencil image icon
let pImg = new Image();
pImg.src = 'pencil.png'
let drawButton = new Square(20, 15, 60, pImg, true)

//Eraser image icon
let eImg = new Image();
eImg.src = 'eraser.png'
let eraseButton = new Square(100, 15, 60, eImg, true)

// Optional: mouse drag for desktop testing
let dragging = false;
let dragObject = null;
let clickStartX = 0;
let clickStartY = 0;


const modes = ['shapes', 'draw', 'erase']
let currentMode = 'shapes'
let currentColor = 'red'

//TESTING DRAWING CODE
 let drawing = false;
 let lines = new Array()
let linePoints = new LinePath([], 8, currentColor); // store all points of a path


function resizeCanvas() {
  canvas.width = window.innerWidth - 2;
  canvas.height = window.innerHeight - 2;
  
  garbage.x = window.innerWidth - 20 - garbage.edge
  garbage.y = window.innerHeight - 20 - garbage.edge
  draw(); // redraw after resize
}

//Functions!!
let getMouseCoords = (canvas, event) => {
    let canvasCoords = canvas.getBoundingClientRect()
    return {
        x: event.pageX - canvasCoords.left,
        y: event.pageY - canvasCoords.top
    }
}

let cursorInRect = (mouseX, mouseY, rectX, rectY, rectW, rectH) => {
    let xLine = mouseX > rectX && mouseX < rectX + rectW
    let yLine = mouseY > rectY && mouseY < rectY + rectH

    return xLine && yLine
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  //Draw the card interface on the right
  garbage.draw(ctx)
  shapes.forEach(e => {
	e.render(ctx)
  })

  lines.forEach(e => {
    redrawPath(e)
  })  
  if(linePoints.points.length > 1)
    redrawPoints(linePoints)

  //Draw the menu on the left
  ctx.fillStyle = '#eeeeff'
  ctx.fillRect(0, 0, 180, canvas.height)
  
  ctx.strokeStyle = 'grey';
  ctx.lineWidth = 2; // optional, makes it thicker

  // Draw vertical line at x = 100
  ctx.beginPath();
  ctx.moveTo(180, 0);                // start at top (y=0)
  ctx.lineTo(180, canvas.height);    // go down to bottom
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, 85);                // start at top (y=0)
  ctx.lineTo(180, 85);    // go down to bottom
  ctx.stroke();
  
  resetButton.draw(ctx)
  
  for (let i = 0; i < colorNames.length; i++) {
    colorButtons[i].draw(ctx)
  }
  
  for (let i = 0; i < shapeNames.length; i++) {
    shapeButtons[i].draw(ctx)
  }
  
  drawButton.draw(ctx)
  eraseButton.draw(ctx)
  /*
  //Draw a square for the drag object
  if(addShape.color == 'white') {
    ctx.fillStyle = '#999999'
  }
  else {
    ctx.fillStyle = '#ffffff'
  }
  ctx.strokeStyle = 'grey';
  ctx.lineWidth = 2; // optional, makes it thicker
  ctx.fillRect(60, 15, 60, 60)
  
  addShape.render(ctx)
  */
  if(dragObject != null) {
    dragObject.render(ctx)
  }

  requestAnimationFrame(draw);
}

//Baby's first draw and resize call
draw();
resizeCanvas();

// Events!!
canvas.addEventListener('touchstart', (e) => {
  for (let i = shapes.length - 1; i >=0; i--) {
	shapes[i].handleTouchStart(e);
  }
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault(); // Prevent scrolling
  for (let i = shapes.length - 1; i >=0; i--) {
	shapes[i].handleTouchMove(e);
  }
});

canvas.addEventListener('touchend', (e) => {
  for (let i = shapes.length - 1; i >=0; i--) {
	shapes[i].handleTouchEnd(e);
  }
});

canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Reset button!!
	  if (cursorInRect(mx, my, resetButton.x, resetButton.y, resetButton.edge, resetButton.edge)) {
		shapes.length = 0
		lines.length = 0
	  }
	  
	  //Color Setting!
	  for (let i = 0; i < colorNames.length; i++) {
		if (cursorInRect(mx, my, colorButtons[i].x, colorButtons[i].y, colorButtons[i].edge, colorButtons[i].edge)) {
	      currentColor = colorButtons[i].color
		  linePoints.color = colorButtons[i].color
		}
	  }
	  
	  
	  //Pen mode toggle!!
	  if (cursorInRect(mx, my, drawButton.x, drawButton.y, drawButton.edge, drawButton.edge)) {
		  if(!drawButton.selected) {
			currentMode = 'draw'
			drawButton.select()
			if(eraseButton.selected) {
			  eraseButton.select()
			}
		  }
		  else {
			currentMode = 'shapes'
			drawButton.select()
		  }
	  }
	  
	  //Erase mode toggle!!
	  if (cursorInRect(mx, my, eraseButton.x, eraseButton.y, eraseButton.edge, eraseButton.edge)) {
		  if(!eraseButton.selected) {
			currentMode = 'erase'
			eraseButton.select()
			if(drawButton.selected) {
			  drawButton.select()
			}
		  }
		  else {
			currentMode = 'shapes'
			eraseButton.select()
		  }
	  }
	  
	  if(currentMode == 'erase') {
		let found = false;
	    for(let i = lines.length - 1; i >= 0; i--) {
		  if(found) { return; }
		  if(lines[i].path != null) { 
		  if(ctx.isPointInStroke(lines[i].path, mx, my)) {
		    lines.splice(i, 1)
			found = true
		  }}
		}
		
		if(!found) {
		  //Look for shapes to destroy indiscriminately
		  for(let i = shapes.length - 1; i >= 0; i--) {
			if(found) break;
		    if(shapes[i].containsPoint(mx, my, ctx)) {
			  //destroy!
			  found = true
			  shapes.splice(i, 1);
			}
		  }
		}
	  }
	  
      draw();
    });

canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if(currentMode != 'shapes') {
    let found = false;
    for (let i = 0; i < shapeNames.length; i++) {
	  if (cursorInRect(x, y, shapeButtons[i].x, shapeButtons[i].y, shapeButtons[i].edge, shapeButtons[i].edge)) {
        found = true
	    currentMode = 'shapes'
	    if(drawButton.selected) drawButton.select()
	    if(eraseButton.selected) eraseButton.select()
	  }
	}
	if (!found) 
	  return;
  }
  for (let i = shapes.length - 1; i >=0; i--) {
	if(dragging) return;
	if (shapes[i].containsPoint(x, y, ctx)) {
	  dragging = true;
	  dragObject = shapes[i]
	  clickStartX = x;
	  clickStartY = y;

	  //push to back of array
	  const [element] = shapes.splice(i, 1);
	  shapes.push(element);
	}
  }
  if(!dragging) {
  
	  //Shape setting!
	  for (let i = 0; i < shapeNames.length; i++) {
		if (cursorInRect(x, y, shapeButtons[i].x, shapeButtons[i].y, shapeButtons[i].edge, shapeButtons[i].edge)) {
		  dragging = true;
		  let newShape = new CanvasShape(x, y, 1, 1, currentColor, shapeButtons[i].shape)
		  shapes.push(newShape)
		  dragObject = newShape
		  clickStartX = x;
		  clickStartY = y;
		}
	  }
  
  
	
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (dragging) {
	const rect = canvas.getBoundingClientRect();
	dragObject.x += e.clientX - rect.left - clickStartX;
	dragObject.y += e.clientY - rect.top - clickStartY;
	clickStartX = e.clientX - rect.left;
	clickStartY = e.clientY - rect.top;
  }
});

canvas.addEventListener('mouseup', (eV) => {

  if(currentMode != 'shapes') {
    return;
  }
  
  let mouse = getMouseCoords(canvas, eV)
  if (cursorInRect(mouse.x, mouse.y, garbage.x, garbage.y, garbage.edge, garbage.edge)) {
	shapes.pop() //Should always be the selected one
  }
  dragging = false;
  dragObject = null
});

// Resize whenever window size changes
window.addEventListener('resize', resizeCanvas);
	
	
//TESTING DRAWING CODE

  function startDrawLine(e) {
  if(currentMode != 'draw' || e.offsetX <= 180) {
    return;
  }
  drawing = true;
  linePoints.points.push({ x: e.offsetX, y: e.offsetY });
  }

  function drawLine(e) {
  if(currentMode != 'draw') {
    return;
  }
    if (!drawing) return;
    linePoints.points.push({ x: e.offsetX, y: e.offsetY });
  }

  function endDrawLine() {
  if(currentMode != 'draw') {
    return;
  }
    if (!drawing) return;
    drawing = false;
	
	//create the path
	let newPath = new Path2D()
    for (let i = 0; i < linePoints.points.length - 1; i++) {
      newPath.moveTo(linePoints.points[i].x, linePoints.points[i].y);
      newPath.lineTo(linePoints.points[i + 1].x, linePoints.points[i + 1].y);
    }
    //newPath.closePath();
	linePoints.path = newPath
	
	lines.push(linePoints)
	linePoints = new LinePath([], 8, currentColor)
  }



function redrawPoints(line) {
  if(line.points.length < 2) { return; }
  //ctx.clearRect(0, 0, canvas.width, canvas.height); // optional: clear before redraw
  ctx.beginPath();
for (let i = 0; i < linePoints.points.length - 1; i++) {
  ctx.moveTo(linePoints.points[i].x, linePoints.points[i].y);
  ctx.lineTo(linePoints.points[i + 1].x, linePoints.points[i + 1].y);
}
  ctx.strokeStyle = line.color;
  ctx.lineWidth = line.thickness;
  ctx.stroke();
  ctx.closePath();
}

function redrawPath(line) {
  //ctx.clearRect(0, 0, canvas.width, canvas.height); // optional: clear before redraw
  ctx.strokeStyle = line.color;
  ctx.lineWidth = line.thickness;
  ctx.stroke(line.path)
}


// Mouse events
canvas.addEventListener('mousedown', startDrawLine);
canvas.addEventListener('mousemove', drawLine);
canvas.addEventListener('mouseup', endDrawLine);
canvas.addEventListener('mouseleave', endDrawLine);	

  </script>
</body>
</html>
<!-- 690, noice -->