<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CanvasShape Test</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      touch-action: none; /* Prevent default gestures */
    }
  </style>
  <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico?">
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas>
  <script>
    // --- CanvasShape class goes here ---
    // (Paste the full class definition from earlier here)

class CanvasShape {
  constructor(x, y, scaleX = 1, scaleY = 1, color = 'red', shape = 'circle') {
    this.x = x;
    this.y = y;
    this.scaleX = scaleX;
    this.scaleY = scaleY;
    this.rotation = 0;
    this.color = color;
    this.shape = shape;

    this.touchStartInfo = null;
  }

  static colors = ['red', 'yellow', 'blue', 'green', 'purple', 'orange', 'pink', 'brown', 'white', 'black'];
  static shapes = ['circle', 'triangle', 'square', 'rectangle', 'heart', 'diamond', 'star'];

  render(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.scale(this.scaleX, this.scaleY);
    ctx.fillStyle = this.color;

    const path = this.getPath(this.shape);
    

    ctx.fill(path);
    ctx.restore();
  }

  getPath(shape) {
    const path = new Path2D();
    switch (shape) {
      case 'circle':
        path.arc(0, 0, 50, 0, Math.PI * 2);
        break;
      case 'square':
        path.rect(-50, -50, 100, 100);
        break;
      case 'rectangle':
        path.rect(-60, -40, 120, 80);
        break;
      case 'triangle':
        path.moveTo(0, -60);
        path.lineTo(50, 40);
        path.lineTo(-50, 40);
        path.closePath();
        break;
      case 'diamond':
        path.moveTo(0, -60);
        path.lineTo(40, 0);
        path.lineTo(0, 60);
        path.lineTo(-40, 0);
        path.closePath();
        break;
      case 'star':
        for (let i = 0; i < 5; i++) {
          const angle = i * (Math.PI * 2) / 5;
          const outerX = Math.cos(angle) * 50;
          const outerY = Math.sin(angle) * 50;
          path.lineTo(outerX, outerY);
          const innerAngle = angle + Math.PI / 5;
          const innerX = Math.cos(innerAngle) * 25;
          const innerY = Math.sin(innerAngle) * 25;
          path.lineTo(innerX, innerY);
        }
        path.closePath();
        break;
      case 'heart':
        path.moveTo(0, 0);
        path.bezierCurveTo(0, -30, -50, -30, -50, 0);
        path.bezierCurveTo(-50, 30, 0, 50, 0, 60);
        path.bezierCurveTo(0, 50, 50, 30, 50, 0);
        path.bezierCurveTo(50, -30, 0, -30, 0, 0);
        break;
    }
    return path;
  }

  containsPoint(x, y, ctx) {
    ctx.save();
    ctx.scale(1 / this.scaleX, 1 / this.scaleY);
    ctx.rotate(-1 * this.rotation);
    ctx.translate(-1 * this.x, -1 * this.y);


    

    const path = this.getPath(this.shape)

    //Transform the mouse xy to properly match it
    const matrix = ctx.getTransform(); // DOMMatrix
    const newPoint = this.transformPoint(x, y, matrix)

    ctx.restore();

    return ctx.isPointInPath(path, newPoint.x, newPoint.y);
  }

  transformPoint(x, y, m) {
    return {
        x: m.a * x + m.c * y + m.e,
        y: m.b * x + m.d * y + m.f
    };
  }

  handleTouchStart(e) {
    if (e.touches.length === 1) {
      this.touchStartInfo = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
    } else if (e.touches.length === 2) {
      const [t1, t2] = e.touches;
      this.touchStartInfo = {
        distance: Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY),
        angle: Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX),
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        rotation: this.rotation
      };
    }
  }

  handleTouchMove(e) {
    if (e.touches.length === 1 && this.touchStartInfo) {
      const dx = e.touches[0].clientX - this.touchStartInfo.x;
      const dy = e.touches[0].clientY - this.touchStartInfo.y;
      this.x += dx;
      this.y += dy;
      this.touchStartInfo.x = e.touches[0].clientX;
      this.touchStartInfo.y = e.touches[0].clientY;
    } else if (e.touches.length === 2 && this.touchStartInfo) {
      const [t1, t2] = e.touches;
      const newDistance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      const newAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);

      const scaleFactor = newDistance / this.touchStartInfo.distance;
      this.scaleX = this.touchStartInfo.scaleX * scaleFactor;
      this.scaleY = this.touchStartInfo.scaleY * scaleFactor;
      this.rotation = this.touchStartInfo.rotation + (newAngle - this.touchStartInfo.angle);
    }
  }

  handleTouchEnd(e) {
    this.touchStartInfo = null;
  }
}

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const shape = new CanvasShape(300, 200, 1, 1, 'pink', 'diamond');
    const shape2 = new CanvasShape(100, 100, 1, 1, 'green', 'circle');

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      shape.render(ctx);
      shape2.render(ctx);
      requestAnimationFrame(draw);
    }

    draw();

    // Touch events
    canvas.addEventListener('touchstart', (e) => {
      shape.handleTouchStart(e);
      shape2.handleTouchStart(e);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault(); // Prevent scrolling
      shape.handleTouchMove(e);
      shape2.handleTouchStart(e);
    });

    canvas.addEventListener('touchend', (e) => {
      shape.handleTouchEnd(e);
      shape2.handleTouchStart(e);
    });

    // Optional: mouse drag for desktop testing
    let dragging = false;
    let clickStartX = 0;
    let clickStartY = 0;

    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (shape.containsPoint(x, y, ctx)) {
        dragging = true;
        clickStartX = x;
        clickStartY = y;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (dragging) {
        const rect = canvas.getBoundingClientRect();
        shape.x += e.clientX - rect.left - clickStartX;
        shape.y += e.clientY - rect.top - clickStartY;
        clickStartX = e.clientX - rect.left;
        clickStartY = e.clientY - rect.top;
      }
    });

    canvas.addEventListener('mouseup', () => {
      dragging = false;
    });
  </script>
</body>
</html>
