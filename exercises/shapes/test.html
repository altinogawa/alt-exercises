<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CanvasShape Test</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      touch-action: none; /* Prevent default gestures */
    }
  </style>
  <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico?">
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas>
  <script>
//Square Class
class Square {
    constructor(x, y, edge, image, outline) {

        this.image = image
        this.x = x
        this.y = y
        this.edge = edge
        this.selected = false
        this.active = false
        this.outline = outline

    }
    draw(context) {
        //context.fillStyle = "gray"

        //context.fillRect(this.x, this.y, this.edge, this.edge)
        context.drawImage(this.image, this.x, this.y, this.edge, this.edge)
        if (this.outline) {
            context.lineWidth = 2;
            context.strokeStyle = "gray"
            context.strokeRect(this.x, this.y, this.edge, this.edge)
        }
    }
    update() {
        this.x += 0.1
    }

    select() {
        this.selected = !this.selected
    }

    activate() {
        this.active = !this.active
    }
}




//Dropdown menu class : )
    class DropdownMenu {
      constructor(x, y, w, h, label, options) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.label = label;
        this.options = options;
        this.isOpen = false;
        this.selected = label;
      }

      draw(ctx) {
        // Draw main button
        ctx.fillStyle = "#ddd";
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = "#000";
        ctx.fillText(this.selected ? this.selected : this.label, this.x + 10, this.y + 20);

        // Draw options if open
        if (this.isOpen) {
          this.options.forEach((opt, i) => {
            const oy = this.y + this.h * (i + 1);
            ctx.fillStyle = "#fff";
            ctx.fillRect(this.x, oy, this.w, this.h);
            ctx.strokeRect(this.x, oy, this.w, this.h);
            ctx.fillStyle = "#000";
            ctx.fillText(opt, this.x + 10, oy + 20);
          });
        }
      }

      handleClick(mx, my) {
        // Toggle menu if main button clicked
        if (mx > this.x && mx < this.x + this.w &&
            my > this.y && my < this.y + this.h) {
          this.isOpen = !this.isOpen;
          return true;
        }

        // Handle option selection
        if (this.isOpen) {
          this.options.forEach((opt, i) => {
            const oy = this.y + this.h * (i + 1);
            if (mx > this.x && mx < this.x + this.w &&
                my > oy && my < oy + this.h) {
              this.selected = opt;
              this.isOpen = false;
            }
          });
        }
        return false;
      }
    }





    // --- CanvasShape class goes here ---
    // (Paste the full class definition from earlier here)
  let colorNames = ['red', 'yellow', 'blue', 'green', 'purple', 'orange', 'pink', 'brown', 'white', 'black'];
  let shapeNames = ['circle', 'triangle', 'square', 'rectangle', 'heart', 'diamond', 'star'];

class CanvasShape {
  constructor(x, y, scaleX = 1, scaleY = 1, color = 'red', shape = 'circle') {
    this.x = x;
    this.y = y;
    this.scaleX = scaleX;
    this.scaleY = scaleY;
    this.rotation = 0;
    this.color = color;
    this.shape = shape;

    this.touchStartInfo = null;
  }


  render(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.scale(this.scaleX, this.scaleY);
    ctx.fillStyle = this.color;

    const path = this.getPath(this.shape);
    

    ctx.fill(path);
    ctx.restore();
  }

  getPath(shape) {
    const path = new Path2D();
    switch (shape) {
      case 'circle':
        path.arc(0, 0, 50, 0, Math.PI * 2);
        break;
      case 'square':
        path.rect(-50, -50, 100, 100);
        break;
      case 'rectangle':
        path.rect(-60, -40, 120, 80);
        break;
      case 'triangle':
        path.moveTo(0, -60);
        path.lineTo(50, 40);
        path.lineTo(-50, 40);
        path.closePath();
        break;
      case 'diamond':
        path.moveTo(0, -60);
        path.lineTo(40, 0);
        path.lineTo(0, 60);
        path.lineTo(-40, 0);
        path.closePath();
        break;
      case 'star':
        for (let i = 0; i < 5; i++) {
          const angle = i * (Math.PI * 2) / 5;
          const outerX = Math.cos(angle) * 50;
          const outerY = Math.sin(angle) * 50;
          path.lineTo(outerX, outerY);
          const innerAngle = angle + Math.PI / 5;
          const innerX = Math.cos(innerAngle) * 25;
          const innerY = Math.sin(innerAngle) * 25;
          path.lineTo(innerX, innerY);
        }
        path.closePath();
        break;
      case 'heart':
        path.moveTo(0, 0);
        path.bezierCurveTo(0, -30, -50, -30, -50, 0);
        path.bezierCurveTo(-50, 30, 0, 50, 0, 60);
        path.bezierCurveTo(0, 50, 50, 30, 50, 0);
        path.bezierCurveTo(50, -30, 0, -30, 0, 0);
        break;
    }
    return path;
  }

  containsPoint(x, y, ctx) {
    ctx.save();
    ctx.scale(1 / this.scaleX, 1 / this.scaleY);
    ctx.rotate(-1 * this.rotation);
    ctx.translate(-1 * this.x, -1 * this.y);


    

    const path = this.getPath(this.shape)

    //Transform the mouse xy to properly match it
    const matrix = ctx.getTransform(); // DOMMatrix
    const newPoint = this.transformPoint(x, y, matrix)

    ctx.restore();

    return ctx.isPointInPath(path, newPoint.x, newPoint.y);
  }

  transformPoint(x, y, m) {
    return {
        x: m.a * x + m.c * y + m.e,
        y: m.b * x + m.d * y + m.f
    };
  }

  handleTouchStart(e) {
    if (e.touches.length === 1) {
      this.touchStartInfo = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
    } else if (e.touches.length === 2) {
      const [t1, t2] = e.touches;
      this.touchStartInfo = {
        distance: Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY),
        angle: Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX),
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        rotation: this.rotation
      };
    }
  }

  handleTouchMove(e) {
    if (e.touches.length === 1 && this.touchStartInfo) {
      const dx = e.touches[0].clientX - this.touchStartInfo.x;
      const dy = e.touches[0].clientY - this.touchStartInfo.y;
      this.x += dx;
      this.y += dy;
      this.touchStartInfo.x = e.touches[0].clientX;
      this.touchStartInfo.y = e.touches[0].clientY;
    } else if (e.touches.length === 2 && this.touchStartInfo) {
      const [t1, t2] = e.touches;
      const newDistance = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      const newAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);

      const scaleFactor = newDistance / this.touchStartInfo.distance;
      this.scaleX = this.touchStartInfo.scaleX * scaleFactor;
      this.scaleY = this.touchStartInfo.scaleY * scaleFactor;
      this.rotation = this.touchStartInfo.rotation + (newAngle - this.touchStartInfo.angle);
    }
  }

  handleTouchEnd(e) {
    this.touchStartInfo = null;
  }
}

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const shapes = new Array()


    shapes.push(new CanvasShape(300, 200, 1, 1, 'pink', 'diamond'))
    shapes.push(new CanvasShape(100, 100, 1, 1, 'green', 'circle'))

// Create two dropdowns
    const shapeMenu = new DropdownMenu(20, 20, 120, 30, "circle", shapeNames);
    const colorMenu = new DropdownMenu(160, 20, 120, 30, "red", colorNames);

// Create preview shape
    const addShape = new CanvasShape (320, 30, 0.5, 0.5, 'red', 'circle')

let gImg = new Image();
gImg.src = '../garbage.png' //FIX THIS
    let garbage = new Square(500, 20, 60, gImg, true)

let rImg = new Image();
rImg.src = '../A.png' //FIX THIS
    let resetButton = new Square(420, 20, 60, rImg, true)

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      garbage.draw(ctx)
      resetButton.draw(ctx)
      addShape.render(ctx)
      shapes.forEach(e => {
        e.render(ctx)
      })

      shapeMenu.draw(ctx);
      colorMenu.draw(ctx);


      requestAnimationFrame(draw);
    }

    draw();

    // Touch events
    canvas.addEventListener('touchstart', (e) => {
      for (let i = shapes.length - 1; i >=0; i--) {
        shapes[i].handleTouchStart(e);
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault(); // Prevent scrolling
      for (let i = shapes.length - 1; i >=0; i--) {
        shapes[i].handleTouchMove(e);
      }
    });

    canvas.addEventListener('touchend', (e) => {
      for (let i = shapes.length - 1; i >=0; i--) {
        shapes[i].handleTouchEnd(e);
      }
    });

    // Optional: mouse drag for desktop testing
    let dragging = false;
    let dragObject = null;
    let clickStartX = 0;
    let clickStartY = 0;

canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Handle clicks for both menus
      if (!shapeMenu.handleClick(mx, my)) {
        if(!colorMenu.handleClick(mx, my)) {
          if (cursorInRect(mx, my, resetButton.x, resetButton.y, resetButton.edge, resetButton.edge)) {
            shapes.length = 0
          }
        }
      }



      addShape.color = colorMenu.selected;
      addShape.shape = shapeMenu.selected;
      draw();
    });

    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      for (let i = shapes.length - 1; i >=0; i--) {
        if(dragging) return;
        if (shapes[i].containsPoint(x, y, ctx)) {
          dragging = true;
          dragObject = shapes[i]
          clickStartX = x;
          clickStartY = y;

          //push to back of array
          const [element] = shapes.splice(i, 1);
          shapes.push(element);
        }
      }
      if(!dragging) {
        if (addShape.containsPoint(x, y, ctx)) {
          dragging = true;
          let newShape = new CanvasShape (320, 30, 1, 1, colorMenu.selected, shapeMenu.selected)
          shapes.push(newShape)
          dragObject = newShape
          clickStartX = x;
          clickStartY = y;


        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (dragging) {
        const rect = canvas.getBoundingClientRect();
        dragObject.x += e.clientX - rect.left - clickStartX;
        dragObject.y += e.clientY - rect.top - clickStartY;
        clickStartX = e.clientX - rect.left;
        clickStartY = e.clientY - rect.top;
      }
    });

let getMouseCoords = (canvas, event) => {
    let canvasCoords = canvas.getBoundingClientRect()
    return {
        x: event.pageX - canvasCoords.left,
        y: event.pageY - canvasCoords.top
    }
}
let cursorInRect = (mouseX, mouseY, rectX, rectY, rectW, rectH) => {
    let xLine = mouseX > rectX && mouseX < rectX + rectW
    let yLine = mouseY > rectY && mouseY < rectY + rectH

    return xLine && yLine
}
    canvas.addEventListener('mouseup', (eV) => {
      let mouse = getMouseCoords(canvas, eV)
      if (cursorInRect(mouse.x, mouse.y, garbage.x, garbage.y, garbage.edge, garbage.edge)) {
        shapes.pop() //Should always be the selected one
      }
      dragging = false;
      dragObject = null
    });
  </script>
</body>
</html>
